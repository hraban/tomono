#+TITLE:        Multi- to Monorepo Migration
#+DESCRIPTION:  Migrate your multirepo to a monorepo using a bash script
#+AUTHOR:       Hraban Luyat
#+EMAIL:        hraban@0brg.net
#+PROPERTY:     header-args       :noweb no-export :eval never
#+EXPORT_FILE_NAME: index.html
#+html_head:    <link rel=stylesheet href=./style.css>
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t ':t
#+options: html-scripts:t html-style:t html5-fancy:t tex:html creator:t date:t author:nil
#+html_doctype: html5
#+html_container: div
#+html_head_extra: <meta name=color-scheme content="light dark">

This script merges multiple independent tiny repositories into a single "monorepo". The summary is ‚Äúevery repo is moved into its own subdirectory, branches are merged.‚Äù See [[Example]] for exactly how this works.

Further reading: https://syslog.ravelin.com/multi-to-mono-repository-c81d004df3ce

#+begin_src sh :eval never :exports code
$ cat my-repos.txt
git@github.com:mycompany/my-repo-abc.git abc
git@github.com:mycompany/my-repo-def.git def
$ /path/to/tomono < my-repos.txt

... noise noise noise

$ cd core # your monorepo is here now
#+end_src

* Features

- üïô Full history of all your prior repos is intact, no changes to checksums
- #Ô∏è‚É£ Signatures of old repos stay valid
- üîÅ Create the monorepo and keep pulling in changes from your minirepos later
- üîÄ Pull in entire new repos as you go, no need to prepare the whole thing at once
- üâë Branches with weird names (slashes, etc)
- üë• No conflicts between files with the same name
- üìÅ Every project gets its own subdirectory

* Usage

Run the =tomono= script with your config on stdin, in the following format:

#+begin_example
git@github.com:mycompany/my-repo-abc.git  abc
git@github.com:mycompany/my-repo-def.git  def
git@github.com:mycompany/my-lib-uuu.git   uuu  lib/uuu
git@github.com:mycompany/my-lib-zzz.git   zzz  lib/zzz
#+end_example

Concrete example:

#+begin_src sh :eval never :exports code
$ cat my-repos.txt | /path/to/tomono
#+end_src

That should be all ‚úÖ.

** Custom name for monorepo directory

Don‚Äôt like =core=? Set a different name through an envvar before running the script:

#+begin_src sh
export MONOREPO_NAME=the-big-repo
#+end_src

** Custom ‚Äúmaster‚Äù / ‚Äúmain‚Äù branch name

No need to do anything. This script does not handle any master / main branch in any special way. It just merges whatever branches exist. Don‚Äôt have a ‚Äúmaster‚Äù branch? None will be created.

Make sure your own computer has the right branch set up in its =init.defaultBranch= setting.

** Continue existing migration

Large teams can‚Äôt afford to ‚Äústop the world‚Äù while a migration is in progress. You‚Äôll be fixing stuff and pulling in new repositories as you go.

Here‚Äôs how to pull in an entirely new set of repositories:

#+begin_src sh :eval never :exports code
/path/to/tomono --continue < my-new-repos.txt
#+end_src

Make sure you have your environment set up exactly the same as above. Particularly, you must be in the parent dir of the monorepo.

* Example

Run these commands to set up a fresh directory with git monorepos that you can later merge:

** Initial setup of fake repos

#+begin_src sh :exports code :eval never-export :results none
d="$(mktemp -d)"
echo "Setting up fresh multi-repos in $d"
cd "$d"

mkdir foo
(
    cd foo
    git init
    git commit -m "foo‚Äôs empty root" --allow-empty
    echo "This is foo" > i-am-foo.txt
    git add -A
    git commit -m "foo‚Äôs master"
    git checkout -b branch-a
    echo "I am a new foo feature" > feature-a.txt
    git add -A
    git commit -m "foo‚Äôs feature branch A"
)

mkdir bar
(
    cd bar
    git init
    echo "This is bar" > i-am-bar.txt
    git add -A
    git commit -m "bar‚Äôs master"
    git checkout -b branch-a
    echo "I am bar‚Äôs side of feature A" > feature-a.txt
    git add -A
    git commit -m "bar‚Äôs feature branch A"
    git branch branch-b master
    git checkout branch-b
    echo "I am an entirely new feature of bar: B" > feature-b.txt
    git add -A
    git commit -m "bar‚Äôs feature branch B"
)
#+end_src

You now have two directories:

- =foo= (branches: =master=, =branch-a=)
- =bar= (branches: =master=, =branch-a=, =branch-b=)

** Combine into monorepo

Assuming the =tomono= script is in your =$PATH=, you can invoke it like this, from that same directory:

#+begin_src sh :exports code :eval never-export :results none
tomono <<EOF
$PWD/foo foo
$PWD/bar bar
EOF
#+end_src

This will create a new directory, =core=, where you can find a git tree which looks somewhat like this:

#+begin_example
,*   0803699 Merge bar/master (HEAD -> master)
|\
,* \   6745370 Merge foo/master
|\ \
,* | | 9f1d472 root commit for monorepo branch master
 / /
| | *   c943466 Merge bar/branch-a (branch-a)
| | |\
| | | * 798a6ca bar‚Äôs feature branch A (bar/branch-a)
| | |/
| |/|
| | *   5ad4187 Merge foo/branch-a
| | |\
| | | * b783ebb foo‚Äôs feature branch A (foo/branch-a)
| |_|/
|/| |
,* | | 66d94bb foo‚Äôs master (foo/master)
 / /
| * 74077da root commit for monorepo branch branch-a
| *   d8bc902 Merge bar/branch-b (branch-b)
| |\
| | * ab40020 bar‚Äôs feature branch B (bar/branch-b)
| |/
|/|
,* | 4a9a874 bar‚Äôs master (bar/master)
 /
,* 2c48815 root commit for monorepo branch branch-b
#+end_example

** Pull in new changes from a remote

It‚Äôs possible that while you‚Äôre working on setting up your fresh monorepo, new changes have been pushed to the existing single repos:

#+begin_src sh :exports code :eval never-export :results none
(
	cd foo
	echo New changes >> i-am-foo.txt
	git commit -va -m 'New changes to foo'
)
#+end_src

Because their history was imported verbatim and nothing has been rewritten, you can import those changes into the monorepo.

First, fetch the changes from the remote:

#+begin_src sh :exports code :eval never :results none
$ cd core
$ git fetch foo
#+end_src

Now merge your changes using subtree merge:

#+begin_src sh
git checkout master
git merge -X subtree=foo/ foo/master
#+end_src

And the updates should be reflected in the monorepo:

#+begin_src sh :exports code :eval never :results none
$ cat foo/i-am-foo.txt
This is foo
New changes
#+end_src

I used the branch master in this example, but any branch works the same way.

** Continue

Now imagine you want to pull in a third repository into the monorepo:

#+begin_src sh :exports code :eval never-export :results none
mkdir zimlib
(
    cd zimlib
    git init
    echo "This is zim" > i-am-zim.txt
    git add -A
    git commit -m "zim‚Äôs master"
    git checkout -b branch-a
    echo "I am a new zim feature" > feature-a.txt
    git add -A
    git commit -m "zim‚Äôs feature branch A"
)
#+end_src

Continue importing it:

#+begin_src sh :exports code :eval never-export :results none
echo "$PWD/zimlib zim lib/zim" | /path/to/tomono --continue
#+end_src

Note that we used a different name for this subrepo, inside the =lib= dir.

The result is that it gets imported into the existing monorepo, alongside the existing two projects:

#+begin_example
$ cd core
$ git checkout master
Switched to branch 'master'
$ tree
.
‚îú‚îÄ‚îÄ bar
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ i-am-bar.txt
‚îú‚îÄ‚îÄ foo
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ i-am-foo.txt
‚îî‚îÄ‚îÄ lib
    ‚îî‚îÄ‚îÄ zim
        ‚îî‚îÄ‚îÄ i-am-zim.txt

4 directories, 3 files
$ git checkout branch-a
Switched to branch 'branch-a'
$ tree
.
‚îú‚îÄ‚îÄ bar
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ feature-a.txt
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ i-am-bar.txt
‚îú‚îÄ‚îÄ foo
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ feature-a.txt
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ i-am-foo.txt
‚îî‚îÄ‚îÄ lib
    ‚îî‚îÄ‚îÄ zim
        ‚îú‚îÄ‚îÄ feature-a.txt
        ‚îî‚îÄ‚îÄ i-am-zim.txt

4 directories, 6 files
$ head **/feature-a.txt
==> bar/feature-a.txt <==
I am bar‚Äôs side of feature A

==> foo/feature-a.txt <==
I am a new foo feature

==> lib/zim/feature-a.txt <==
I am a new zim feature
#+end_example

** Tags

Tags are namespaced per remote, to avoid clashes. If your remote =foo= and =bar= both have a tag =v1.0.0=, your monorepo ends up with =foo/v1.0.0= and =bar/v1.0.0= pointing at their relevant commits.

N.B.: This concerns light-weight tags! Annotated tags are a different beast and unfortunately they can‚Äôt be rewritten this way.

If you don‚Äôt like this rewriting, you can remove all tags, and fetch them fresh from the remotes:

#+begin_src sh :eval never :export code :results none
$ cat ... |  .../tomono
$ cd core
$ rm -rf .git/refs/tags
$ git fetch --all --tags
#+end_src

Be prepared to deal with any conflicts!

* Implementation

#+begin_quote
(This section is best viewed at [[https://hraban.github.io/tomono/]], the GitHub Readme viewer misses some info)
#+end_quote

The outer program structure is a flat bash script which loops over every repo supplied over stdin:

#+CAPTION: top-level
#+NAME: top-level
#+BEGIN_SRC shell :tangle tomono :comments link :shebang "#!/usr/bin/env bash" :references yes

<<set-flags>>

<<prep-dir>>

# Note this is top-level in the script so it‚Äôs reading from the script‚Äôs stdin
while read repourl reponame repopath; do
    if [[ -z "$repopath" ]]; then
        repopath="$reponame"
    fi

    <<handle-remote>>
done

<<finalize>>

# <<copyright>>
#+END_SRC

** Per repository

Every repository is fetched and fully handled individually, and sequentially:

1. fetch all the data related to this repository,
2. immediately check out and initialise every single branch which belongs to that repository.

#+CAPTION: handle-remote
#+NAME: handle-remote
#+BEGIN_SRC shell :comments link :references yeye
  git remote add "$reponame" "$repourl"
  git fetch --tags --atomic "$reponame"
  <<namespace-remote-tags>>
  <<list-branches>> | while read branch ; do
      <<handle-branch>>
  done
#+END_SRC

** Per branch (this is where the magic happens)

In the context of /a single repository check-out/, every branch is independently checked out into a subdir for that repository, and merged into the monorepo.

This is the money shot.

#+CAPTION: handle-branch
#+NAME: handle-branch
#+BEGIN_SRC sh
<<ensure-on-target-branch-in-monorepo>>
mkdir -p "$repopath"
git merge --strategy=ours "$reponame/$branch" --allow-unrelated-histories --no-commit --no-ff
git --work-tree "./$repopath/" checkout "$reponame/$branch" -- .
git add -A
git commit -m "Merge $reponame/$branch" --allow-empty
#+END_SRC

N.B.: We check out the full tree every time, and commit it. There is probably some high-tech git trick we could pull to do this in cache only, without actually touching the filesystem, but I‚Äôve found this method to be reliable and ‚Äúfast enough.‚Äù It‚Äôs actually doggone slow, but hopefully you only migrate to a monorepo once in your entire life, so amortised it ends up being a wash.

That being said, mercy on your soul if you try to migrate the linux kernel.

*** Ensure we are on the right branch

In this snippet, we ensure that we are ready to merge fresh code from a subrepo into this branch: either we checkout an existing branch in the monorepo by this name, or we create a fresh one.

We are given the variable =$branch= which is the final name of the branch we want to operate on. It is the same as the name of the branch in each individual target repo.

#+CAPTION: ensure-on-target-branch-in-monorepo
#+NAME: ensure-on-target-branch-in-monorepo
#+BEGIN_SRC sh
if git checkout --orphan "$branch"; then
    git rm -rf --cached . || :
    git clean -dfx
    git commit --allow-empty -m "root commit for monorepo branch $branch"
else
    git checkout "$branch"
fi
#+END_SRC

Technically; we do it the other way around :) First I try to create a fresh branch, and only if that fails, I switch to the existing one. This way I'm sure that a branch exists, so when I =git checkout "$branch"= , I don't clash with a filename, instead.

Neat side effect of =git checkout --orphan=: if the branch already exists, but has no commits at all on it, the operation succeeds as if the branch were freshly created. This helps us with the very first commit on =master=, which will have been automatically created as part of =git init=:

#+begin_comment
I'm sure there is a cooler way to do this, but I find my current options lacking. The HTML output is unreadable.

E.g. the HTML export of this:

#+begin_src sh :tangle no :results inline :exports both
date
#+end_src

results in two completely separate blocks. This makes a interactive shell session with multiple individual commands hard to follow. Would be nice to have some sort of plugin for this.
#+end_comment

#+begin_src sh :tangle no :exports code
$ cd "$(mktemp -d)"

$ git init
...

$ git status
On branch master
...

$ git checkout --orphan master
Switched to a new branch 'master'
$ echo $?
0

$ echo foo > bar ; git add bar ; git commit -m first
...

$ git checkout --orphan master
fatal: A branch named 'master' already exists.
$ echo $?
128
#+end_src

As you can see, doing =git checkout --orphan= on master on a fresh repo is no problem. Otherwise we would have had to special case it.

I'm sure this would still fail on some cases, e.g. branch names starting with a =-=. Ideally, I'd like a plumbing command to really just =git checkout-branch -- <branch-name>= no matter what. I'm sure the new =git switch= can help, but, quoth the man page:

#+begin_src :tangle no
THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.
#+end_src

Ah well. Don't start your branch names with =-=, I guess?

** Set up the monorepo directory

We create a fresh directory for this script to run in, or continue on an existing one if the =--continue= flag is passed.

#+CAPTION: prep-dir
#+NAME: prep-dir
#+BEGIN_SRC sh
# Poor man‚Äôs arg parse :/
arg="${1-}"
: "${MONOREPO_NAME:=core}"

if [[ "$arg" == "" ]]; then
	if [[ -d "$MONOREPO_NAME" && "$arg" != "--continue" ]]; then
		>&2 echo "monorepo directory $MONOREPO_NAME already exists"
		exit 1
	fi
	mkdir "$MONOREPO_NAME"
	cd "$MONOREPO_NAME"
	git init
elif [[ "$arg" != "--continue" ]]; then
	>&2 echo "Unexpected argument: $arg"
	>&2 echo
	>&2 echo "Usage: $0 [--continue]"
	exit 1
elif [[ ! -d "$MONOREPO_NAME" ]]; then
	>&2 echo "Asked to --continue, but monorepo directory $MONOREPO_NAME doesn‚Äôt exist"
	exit 1
else
	cd "$MONOREPO_NAME"
	# There isn‚Äôt anything special about --continue, really.
fi

<<prep-tags>>
#+END_SRC

Most of rigmarole is about UI, and preventing mistakes. As you can see, there is functionally no difference between continuing and starting fresh, beyond =mkdir= and =git init=. At the end of the day, every repo is read in greedily, and whether you do that on an existing monorepo, or a fresh one, doesn‚Äôt matter: every repo name you read in, is in fact itself like a =--continue= operation.

It‚Äôs horrible and kludgy but I just want to get something working out the door, for now.

** List individual branches

I want a single branch name per line on stdout, for a single specific remote:

#+CAPTION: list-branches
#+NAME: list-branches
#+BEGIN_SRC sh
git branch -r --no-color --list "$reponame/*" --format "%(refname:lstrip=3)"
#+END_SRC

*** Implementations that didn‚Äôt make the cut

Solutions I abandoned, due to one short-coming or another:

**** =git branch -r= with grep

The most straight-forward way to list branch names:

#+begin_src sh :eval never :exports code :results none
$ git branch -r
  bar/branch-a
  bar/branch-b
  bar/master
  foo/branch-a
  foo/master
#+end_src

This could be combined with =grep= to filter all branches for a specific remote, and filter out the name. It‚Äôs very close, but how do you reliably remove an unknown string?

**** =find .git/refs/hooks=

#+begin_src sh
( cd ".git/refs/remotes/$reponame" && find . -type f -mindepth 1 | sed -e s/..// )
#+end_src

Closer, but ugly, and I got reports that it missed some branches (although I was never able to repro)

**** =git ls-remote=

#+begin_src sh
git ls-remote --heads --refs "$reponame" | sed 's_[^ ]* *refs/heads/__'
#+end_src

Originally suggested in a [[https://github.com/hraban/tomono/pull/39][PR 39]], I‚Äôve decided not to use this because =git-ls-remote= actively queries the remote to list its branches, rather than inspecting the local state of whatever we just fetched. That feels like a race condition at best, and becomes very annoying if you‚Äôre dealing with password protected remotes or otherwise inaccessible repos.

** Tags

Light weight tags are just refs, and they‚Äôre all stored in a predictable place in the =.git= directory. The easiest way to manage them is to juggle that directory after each fetch.

We start by storing all our existing tags somewhere out of git‚Äôs reach:

#+caption: prep-tags
#+name: prep-tags
#+begin_src sh :references yes
(
	cd .git/refs
	mv tags tags-aux
)
#+end_src

and once everything is done, we move them back:

#+caption: finalize
#+name: finalize
#+begin_src sh :references yes
(
	cd .git/refs
	mv tags-aux tags
)
#+end_src

The real magic happens just after a remote has been fetched (see [[handle-remote]]). We now know for sure that all tags actually only belong to that remote, so we can namespace them all together:

#+caption: namespace-remote-tags
#+name: namespace-remote-tags
#+begin_src sh :references yes
(
	cd .git/refs
	if [[ -d tags ]]; then
		tagdir="tags-aux/$reponame"
		mkdir -p "$tagdir"
		rmdir "$tagdir"
		mv tags "$tagdir"
	fi
)
#+end_src

The =mkdir -p .. ; rmdir ..= trick is the easiest way to create a directory‚Äôs parent, without creating the directory itself. I don‚Äôt like process substitution (=mkdir "$(dirname ...)"=, yuck).

** Error flags, warnings, debug

Various sh flags allow us to control the behaviour of the shell: treat
any unknown variable reference as an error, treat any non-zero exit
status in a pipeline as an error (instead of only looking at the last
program), and treat any error as fatal and quit. Additionally, if the
=DEBUGSH= environment variable is set, enable "debug" mode by echoing
every command before it gets executed.

#+CAPTION: set-flags
#+NAME: set-flags
#+BEGIN_SRC sh
set -euo pipefail ${DEBUGSH+-x}
#+END_SRC

* Building the code                                                :noexport:

The easiest way to build everything in this repo is using docker:

#+begin_src sh :exports code :results none :eval never-export
docker-compose run --rm build
#+end_src

Most of the code in this repository is generated from this readme file. This can be done in stock Emacs, by opening this file and calling =M-x org-babel-tangle=.

This file can also be exported to HTML. Executing the block below, before you export it, adds some extra flourish to that exported file:

#+BEGIN_SRC emacs-lisp :exports code :results none :tangle export-html.el
;; This is configuration for org mode itself, not tomono src code. Don't export this.

;; TODO: Clean this up. No globals etc.

(require 'cl-lib)
(require 'dash)
(require 's)

(defun org-info-name (info)
  (nth 4 info))

(defun insert-ln (&rest args)
  (apply #'insert args)
  (newline))

(defun should-reference (info)
  "Determine if this info block is a referencing code block"
  (not (memq (alist-get :noweb (nth 2 info))
             '(nil "no"))))

(defun re-findall (re str &optional offset)
  "Find all matches of a regex in the given string"
  (let ((start (string-match re str offset))
        (end (match-end 0)))
    (when (numberp start)
      (cons (substring str start end) (re-findall re str end)))))

;; Match groups are the perfect tool to achieve this but EL's regex is
;; inferior and it's not worth the hassle. Blag it manually.

(defun strip-delimiters (s prefix suffix)
  "Strip a prefix and suffix delimiter, e.g.:
(strip-delimiters \"<a>\" \"<\" \">\")
=> \"a\"

Note this function trusts the input string has those delimiters"
  (substring s (length prefix) (- (length suffix))))

(defun strip-noweb-delimiters (s)
  "Strip the org noweb link delimiters, usually << and >>"
  (strip-delimiters s org-babel-noweb-wrap-start org-babel-noweb-wrap-end))

(defun extract-refs (body)
  (mapcar #'strip-noweb-delimiters (re-findall (org-babel-noweb-wrap) body)))

(defun add-to-hash-list (k elem hash)
  "Assuming the hash values are lists, add this element to k's list"
  (puthash k (cons elem (gethash k hash)) hash))

(defun register-refs (name refs)
  (puthash name refs forward-refs)
  ;; Add a backreference to every ref
  (mapc (lambda (ref)
          (add-to-hash-list ref name back-refs))
        refs))

(defun parse-blocks ()
  (let ((forward-refs (make-hash-table :test 'equal))
        (back-refs (make-hash-table :test 'equal)))
    (org-babel-map-src-blocks nil
      ;; Probably not v efficient, but should be memoized anyway?
      (let* ((info (org-babel-get-src-block-info full-block))
             (name (org-info-name info)))
        (when (and name (should-reference info))
          (register-refs name (extract-refs body)))))
    (list forward-refs back-refs)))

(defun tomono--format-ref (ref)
  (format "[[%s][%s]]" ref ref))

(defun insert-references-block (info title refs)
  (when refs
    (insert title)
    (->> refs (mapcar 'tomono--format-ref) (s-join ", ") insert-ln)
    (newline)))

(defun insert-references (info forward back)
  (when (or forward back)
    (newline)
    (insert-ln ":REFERENCES:")
    (insert-references-block info "References: " forward)
    (insert-references-block info "Used by: " back)
    (insert-ln ":END:")))

(defun get-references (name)
  (list (gethash name forward-refs) (gethash name back-refs)))

(defun fix-references (backend)
  "Append a references section to every noweb codeblock"
  (cl-destructuring-bind (forward-refs back-refs) (parse-blocks)
    (org-babel-map-src-blocks nil
      (let ((info (org-babel-get-src-block-info full-block)))
        (when (should-reference info)
          (pcase-let ((`(,language ,body ,arguments ,switches ,name ,start ,coderef) info))
            (goto-char end-block)
            (apply #'insert-references info (get-references name))))))))

(add-hook 'org-export-before-parsing-hook 'fix-references nil t)

;; The HTML output
(let ((org-html-htmlize-output-type 'css))
  (org-html-export-to-html))
#+END_SRC

* Copyright and license

This is a cleanroom reimplementation of the tomono.sh script, originally written with copyright assigned to Ravelin Ltd., a UK fraud detection company. There were some questions around licensing, and it was unclear how to go forward with maintenance of this project given its dispersed copyright, so I went ahead and rewrote the entire thing for a fresh start.

The license and copyright attribution of this entire document can now be set:

#+CAPTION: copyright
#+NAME: copyright
#+BEGIN_SRC fundamental
Copyright ¬© 2020, 2022 Hraban Luyat

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+END_SRC

I did not look at the original implementation at all while developing this.
