<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-03-17 Sun 07:03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multi- to Monorepo Migration</title>
<meta name="description" content="Migrate your multirepo to a monorepo using a bash script" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel=stylesheet href=./style.css>
<meta name=color-scheme content="light dark">
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Multi- to Monorepo Migration</h1>
</header><p>
This script merges multiple independent tiny repositories into a single &ldquo;monorepo&rdquo;. Every original repo is moved into its own subdirectory, branches with the same name are all merged. See <a href="#example">Example</a> for the details.
</p>

<p>
Download the <code>tomono</code> script on <a href="https://github.com/hraban/tomono">github.com/hraban/tomono</a>.
</p>

<nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0dc1f0c">1. Features</a></li>
<li><a href="#orgf710eb3">2. Usage</a></li>
<li><a href="#example">3. Example</a></li>
<li><a href="#implementation">4. Implementation</a></li>
<li><a href="#tests">5. Tests</a></li>
<li><a href="#org80755b8">6. Copyright and license</a></li>
</ul>
</div>
</nav>

<div id="outline-container-org0dc1f0c" class="outline-2">
<h2 id="org0dc1f0c"><span class="section-number-2">1.</span> Features</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>üïô Full history of all your prior repos is intact, no changes to checksums</li>
<li>#Ô∏è‚É£ Signatures of old repos stay valid</li>
<li>üîÅ Create the monorepo and keep pulling in changes from your minirepos later</li>
<li>üîÄ Pull in entire new repos as you go, no need to prepare the whole thing at once</li>
<li>üè∑ Tags are namespaced to avoid clashes, but tag signatures remain valid</li>
<li>üâë Branches with weird names (slashes, etc)</li>
<li>üë• No conflicts between files with the same name</li>
<li>üìÅ Every project gets its own subdirectory</li>
</ul>
</div>
</div>

<div id="outline-container-orgf710eb3" class="outline-2">
<h2 id="orgf710eb3"><span class="section-number-2">2.</span> Usage</h2>
<div class="outline-text-2" id="text-2">
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga013d50">2.1. Custom name for monorepo directory</a></li>
<li><a href="#orgc3328c9">2.2. Custom ‚Äúmaster‚Äù / ‚Äúmain‚Äù branch name</a></li>
<li><a href="#orgdb17511">2.3. Continue existing migration</a></li>
<li><a href="#org8e52b3f">2.4. Tags</a></li>
</ul>
</div>

<p>
Run the <code>tomono</code> script with your config on stdin, in the following format:
</p>

<pre class="example" id="org2e74094">
$ cat my-repos.txt
git@github.com:mycompany/my-repo-abc.git  abc
git@github.com:mycompany/my-repo-def.git  def
git@github.com:mycompany/my-lib-uuu.git   uuu  lib/uuu
git@github.com:mycompany/my-lib-zzz.git   zzz  lib/zzz
https://gitee.com/shijie/zhongguo.git     ‰∏≠ÂõΩ
</pre>

<p>
Concrete example:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ cat my-repos.txt | /path/to/tomono
</pre>
</div>

<p>
That should be all ‚úÖ.
</p>
</div>

<div id="outline-container-orga013d50" class="outline-3">
<h3 id="orga013d50"><span class="section-number-3">2.1.</span> Custom name for monorepo directory</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Don‚Äôt like <code>core</code>? Set a different name through an envvar before running the script:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">export</span> <span class="org-variable-name">MONOREPO_NAME</span>=the-big-repo
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc3328c9" class="outline-3">
<h3 id="orgc3328c9"><span class="section-number-3">2.2.</span> Custom ‚Äúmaster‚Äù / ‚Äúmain‚Äù branch name</h3>
<div class="outline-text-3" id="text-2-2">
<p>
No need to do anything. This script does not handle any master / main branch in any special way. It just merges whatever branches exist. Don‚Äôt have a ‚Äúmaster‚Äù branch? None will be created.
</p>

<p>
Make sure your own computer has the right branch set up in its <code>init.defaultBranch</code> setting.
</p>
</div>
</div>

<div id="outline-container-orgdb17511" class="outline-3">
<h3 id="orgdb17511"><span class="section-number-3">2.3.</span> Continue existing migration</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Large teams can‚Äôt afford to ‚Äústop the world‚Äù while a migration is in progress. You‚Äôll be fixing stuff and pulling in new repositories as you go.
</p>

<p>
Here‚Äôs how to pull in an entirely new set of repositories:
</p>

<div class="org-src-container">
<pre class="src src-shell">/path/to/tomono --continue &lt; my-new-repos.txt
</pre>
</div>

<p>
Make sure you have your environment set up exactly the same as above. Particularly, you must be in the parent dir of the monorepo.
</p>
</div>
</div>

<div id="outline-container-org8e52b3f" class="outline-3">
<h3 id="org8e52b3f"><span class="section-number-3">2.4.</span> Tags</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Tags are namespaced per remote, to avoid clashes. If your remote <code>foo</code> and <code>bar</code> both have a tag <code>v1.0.0</code>, your monorepo ends up with <code>foo/v1.0.0</code> and <code>bar/v1.0.0</code> pointing at their relevant commits.
</p>

<p>
If you don‚Äôt like this rewriting, you can fetch all tags from a specific remote to the top-level of the monorepo:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ git fetch --tags foo
</pre>
</div>

<p>
Be prepared to deal with any conflicts.
</p>
</div>

<div id="outline-container-orgeb5c091" class="outline-4">
<h4 id="orgeb5c091"><span class="section-number-4">2.4.1.</span> Lightweight vs. Annotated Tags</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
N.B.: This namespacing works for all tags: lightweight, annotated, signed. However, for the latter two, there is one snag: an annotated tag contains its own tag name as part of the commit. I have chosen not to modify the object itself, so the annotated tag object thinks it still has its old name. This is a mixed bag: it depends on your case whether that‚Äôs a feature or a bug. One major advantage of this approach is that signed tags remain valid. But you will occasionally get messages like:
</p>

<pre class="example" id="org8e9a313">
$ git describe linux/v5.9-rc4
warning: tag 'linux/v5.9-rc4' is externally known as 'v5.9-rc4'
v5.9-rc4-0-gf4d51dffc6c0
</pre>

<p>
If you know what you‚Äôre doing, you can force update all signed and annotated tags to their (nested) ref tag name with the following snippet:
</p>

<div class="org-src-container">
<pre class="src src-shell">git for-each-ref --format <span class="org-string">'%(objecttype) %(refname:lstrip=2)'</span> | <span class="org-sh-escaped-newline">\</span>
    sed -ne <span class="org-string">'s/^tag //p'</span> |
    <span class="org-variable-name">GIT_EDITOR</span>=true xargs -I + -n 1 -- git tag -f -a + +^{}
</pre>
</div>

<p>
N.B.: this will convert all signed tags to regular annotated tags (their signatures would fail anyway).
</p>

<p>
Source: <a href="https://github.com/mwasilew2/tomono/commit/16aa7918aa9d912a30b563152bda62c77414cbe1">GitHub user mwasilew2</a>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-example" class="outline-2">
<h2 id="example"><span class="section-number-2">3.</span> Example</h2>
<div class="outline-text-2" id="text-example">
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1092782">3.1. Initial setup of fake repos</a></li>
<li><a href="#orgf3b95e6">3.2. Combine into monorepo</a></li>
<li><a href="#org04f0622">3.3. Pull in new changes from a remote</a></li>
<li><a href="#org9d195b9">3.4. Continue</a></li>
</ul>
</div>

<p>
Run these commands to set up a fresh directory with git monorepos that you can later merge:
</p>
</div>

<div id="outline-container-org1092782" class="outline-3">
<h3 id="org1092782"><span class="section-number-3">3.1.</span> Initial setup of fake repos</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-shell"><span class="org-variable-name">d</span>=<span class="org-string">"$(</span><span class="org-sh-quoted-exec">mktemp -d</span><span class="org-string">)"</span>
<span class="org-builtin">echo</span> <span class="org-string">"Setting up fresh multi-repos in $d"</span>
<span class="org-builtin">cd</span> <span class="org-string">"$d"</span>

mkdir foo
(
    <span class="org-builtin">cd</span> foo
    git init
    git commit -m <span class="org-string">"foo&#8217;s empty root"</span> --allow-empty
    <span class="org-builtin">echo</span> <span class="org-string">"This is foo"</span> &gt; i-am-foo.txt
    git add -A
    git commit -m <span class="org-string">"foo&#8217;s master"</span>
    git tag v1.0
    git checkout -b branch-a
    <span class="org-builtin">echo</span> <span class="org-string">"I am a new foo feature"</span> &gt; feature-a.txt
    git add -A
    git commit -m <span class="org-string">"foo&#8217;s feature branch A"</span>
)

mkdir &#20013;&#25991;
(
    <span class="org-builtin">cd</span> &#20013;&#25991;
    git init
    <span class="org-builtin">echo</span> <span class="org-string">"&#20320;&#22909;"</span> &gt; &#20320;&#22909;.txt
    git add -A
    git commit -m <span class="org-string">"&#20013;&#25991;&#30340;root"</span>
    git tag v1.0
    git checkout -b branch-a
    <span class="org-builtin">echo</span> <span class="org-string">"&#20320;&#22909; from feature-a"</span> &gt; feature-a.txt
    git add -A
    git commit -m <span class="org-string">"new &#20013;&#25991; feature branch A"</span>
    git branch branch-b master
    git checkout branch-b
    <span class="org-builtin">echo</span> <span class="org-string">"I am an entirely new &#20013;&#25991; feature: B"</span> &gt; feature-b.txt
    git add -A
    git commit -m <span class="org-string">"&#20013;&#25991;&#8217;s feature branch B"</span>
)
</pre>
</div>

<p>
You now have two directories:
</p>

<ul class="org-ul">
<li><code>foo</code> (branches: <code>master</code>, <code>branch-a</code>)</li>
<li><code>‰∏≠Êñá</code> (branches: <code>master</code>, <code>branch-a</code>, <code>branch-b</code>)</li>
</ul>
</div>
</div>

<div id="outline-container-orgf3b95e6" class="outline-3">
<h3 id="orgf3b95e6"><span class="section-number-3">3.2.</span> Combine into monorepo</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Assuming the <code>tomono</code> script is in your <code>$PATH</code>, you can invoke it like this, from that same directory:
</p>

<div class="org-src-container">
<pre class="src src-shell">tomono &lt;&lt;EOF
<span class="org-sh-heredoc">$PWD/foo foo</span>
<span class="org-sh-heredoc">$PWD/&#20013;&#25991; &#20013;&#25991;</span>
<span class="org-sh-heredoc">EOF</span>
</pre>
</div>

<p>
This will create a new directory, <code>core</code>, where you can find a git tree which looks somewhat like this:
</p>

<pre class="example" id="org1388fb3">
*   b742af2 Merge ‰∏≠Êñá/branch-a (branch-a)
|\
| * c05c53c new ‰∏≠Êñá feature branch A (‰∏≠Êñá/branch-a)
* |   a51d138 Merge foo/branch-a
|\ \
| * | ebb490a foo‚Äôs feature branch A (foo/branch-a)
* | | a08fa18 Root commit for monorepo branch branch-a
 / /
| | *   c53bf94 Merge ‰∏≠Êñá/branch-b (branch-b)
| | |\
| | | * 5e7f4f5 ‰∏≠Êñá‚Äôs feature branch B (‰∏≠Êñá/branch-b)
| | |/
| |/|
| | * 2738327 Root commit for monorepo branch branch-b
| |
| | *   9a4b33a Merge ‰∏≠Êñá/master (HEAD -&gt; master)
| | |\
| | |/
| |/|
| * | a9841a8 ‰∏≠ÊñáÁöÑroot (tag: ‰∏≠Êñá/v1.0, ‰∏≠Êñá/master)
|  /
| *   b75840e Merge foo/master
| |\
| |/
|/|
* | 1515265 foo‚Äôs master (tag: foo/v1.0, foo/master)
* | f71fcde foo‚Äôs empty root
 /
* 7803cf5 Root commit for monorepo branch master
</pre>
</div>
</div>

<div id="outline-container-org04f0622" class="outline-3">
<h3 id="org04f0622"><span class="section-number-3">3.3.</span> Pull in new changes from a remote</h3>
<div class="outline-text-3" id="text-3-3">
<p>
It‚Äôs possible that while you‚Äôre working on setting up your fresh monorepo, new changes have been pushed to the existing single repos:
</p>

<div class="org-src-container">
<pre class="src src-shell">(
    <span class="org-builtin">cd</span> foo
    <span class="org-builtin">echo</span> New changes &gt;&gt; i-am-foo.txt
    git commit -va -m <span class="org-string">'New changes to foo'</span>
)
</pre>
</div>

<p>
Because their history was imported verbatim and nothing has been rewritten, you can import those changes into the monorepo.
</p>

<p>
First, fetch the changes from the remote:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ cd core
$ git fetch foo
</pre>
</div>

<p>
Now merge your changes using subtree merge:
</p>

<div class="org-src-container">
<pre class="src src-shell">git checkout master
git merge -X <span class="org-variable-name">subtree</span>=foo/ foo/master
</pre>
</div>

<p>
And the updates should be reflected in the monorepo:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ cat foo/i-am-foo.txt
This is foo
New changes
</pre>
</div>

<p>
I used the branch master in this example, but any branch works the same way.
</p>
</div>
</div>

<div id="outline-container-org9d195b9" class="outline-3">
<h3 id="org9d195b9"><span class="section-number-3">3.4.</span> Continue</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Now imagine you want to pull in a third repository into the monorepo:
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir zimlib
(
    <span class="org-builtin">cd</span> zimlib
    git init
    <span class="org-builtin">echo</span> <span class="org-string">"This is zim"</span> &gt; i-am-zim.txt
    git add -A
    git commit -m <span class="org-string">"zim&#8217;s master"</span>
    git checkout -b branch-a
    <span class="org-builtin">echo</span> <span class="org-string">"I am a new zim feature"</span> &gt; feature-a.txt
    git add -A
    git commit -m <span class="org-string">"zim&#8217;s feature branch A"</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">And some more weird stuff, to mess with you</span>
    git checkout master
    git checkout -d
    <span class="org-builtin">echo</span> top secret &gt; james-bond.txt
    git add -A
    git commit -m <span class="org-string">"I am unreachable"</span>
    git tag leaking-you HEAD
    git checkout --orphan empty-branch
    git rm --cached -r .
    git clean -dfx
    git commit -m <span class="org-string">"zim&#8217;s tricky empty orphan branch"</span> --allow-empty
)
</pre>
</div>

<p>
Continue importing it:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> <span class="org-string">"$PWD/zimlib zim lib/zim"</span> | tomono --continue
</pre>
</div>

<p>
Note that we used a different name for this subrepo, inside the <code>lib</code> dir.
</p>

<p>
The result is that it gets imported into the existing monorepo, alongside the existing two projects:
</p>

<pre class="example" id="org8e1b0df">
$ cd core
$ git checkout master
Switched to branch 'master'
$ tree
.
‚îú‚îÄ‚îÄ foo
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ i-am-foo.txt
‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îî‚îÄ‚îÄ zim
‚îÇ       ‚îî‚îÄ‚îÄ i-am-zim.txt
‚îî‚îÄ‚îÄ ‰∏≠Êñá
    ‚îî‚îÄ‚îÄ ‰Ω†Â•Ω.txt

4 directories, 3 files
$ git checkout branch-a
Switched to branch 'branch-a'
$ tree
.
‚îú‚îÄ‚îÄ foo
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ feature-a.txt
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ i-am-foo.txt
‚îú‚îÄ‚îÄ lib
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ zim
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ feature-a.txt
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ i-am-zim.txt
‚îî‚îÄ‚îÄ ‰∏≠Êñá
    ‚îú‚îÄ‚îÄ feature-a.txt
    ‚îî‚îÄ‚îÄ ‰Ω†Â•Ω.txt

4 directories, 6 files
$ head **/feature-a.txt
==&gt; foo/feature-a.txt &lt;==
I am a new foo feature

==&gt; lib/zim/feature-a.txt &lt;==
I am a new zim feature

==&gt; ‰∏≠Êñá/feature-a.txt &lt;==
‰Ω†Â•Ω from feature-a
</pre>
</div>
</div>
</div>

<div id="outline-container-implementation" class="outline-2">
<h2 id="implementation"><span class="section-number-2">4.</span> Implementation</h2>
<div class="outline-text-2" id="text-implementation">
<blockquote>
<p>
(This section is best viewed in <a href="https://tomono.0brg.net/#implementation">HTML form</a>; the GitHub Readme viewer misses some info.)
</p>
</blockquote>

<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org91e215a">4.1. Per repository</a></li>
<li><a href="#org872acef">4.2. Per branch (this is where the magic happens)</a></li>
<li><a href="#orge65d899">4.3. Set up the monorepo directory</a></li>
<li><a href="#org45f071a">4.4. List individual branches</a></li>
<li><a href="#orgf50426b">4.5. Init &amp; finalize</a></li>
</ul>
</div>

<p>
The outer program structure is a flat bash script which loops over every repo supplied over stdin:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>top-level</label><pre class="src src-shell" id="org69b2cda">&lt;&lt;init&gt;&gt;

<span class="org-comment-delimiter"># </span><span class="org-comment">Note this is top-level in the script so it&#8217;s reading from the script&#8217;s stdin</span>
<span class="org-keyword">while</span> &lt;&lt;windows-fix&gt;&gt; read -r repourl reponame repopath; <span class="org-keyword">do</span>
<span class="org-sh-heredoc">    if [[ -z "$repopath" ]]; then</span>
<span class="org-sh-heredoc">        repopath="$reponame"</span>
<span class="org-sh-heredoc">    fi</span>

<span class="org-sh-heredoc">    &lt;&lt;handle-remote&gt;&gt;</span>
<span class="org-sh-heredoc">done</span>

<span class="org-sh-heredoc">&lt;&lt;finalize&gt;&gt;</span>

<span class="org-sh-heredoc"># &lt;&lt;copyright&gt;&gt;</span>
</pre>
</div>
<p>
References: <a href="#org18a4165">init</a>, <a href="#org23b82b3">windows-fix</a>, <a href="#org53653f9">handle-remote</a>, <a href="#org48356eb">finalize</a>, <a href="#org36a558f">copyright</a>
</p>
</div>


<div id="outline-container-org91e215a" class="outline-3">
<h3 id="org91e215a"><span class="section-number-3">4.1.</span> Per repository</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Every repository is fetched and fully handled individually, and sequentially:
</p>

<ol class="org-ol">
<li>fetch all the data related to this repository,</li>
<li>immediately check out and initialise every single branch which belongs to that repository.</li>
</ol>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>handle-remote</label><pre class="src src-shell" id="org53653f9">git remote add <span class="org-string">"$reponame"</span> <span class="org-string">"$repourl"</span>
git config --add <span class="org-string">"remote.$reponame.fetch"</span> <span class="org-string">"+refs/tags/*:refs/tags/$reponame/*"</span>
git config <span class="org-string">"remote.$reponame.tagOpt"</span> --no-tags
git fetch --atomic <span class="org-string">"$reponame"</span>

&lt;&lt;list-branches&gt;&gt; | <span class="org-keyword">while </span><span class="org-builtin">read</span> -r branch ; <span class="org-keyword">do</span>
<span class="org-sh-heredoc">    &lt;&lt;handle-branch&gt;&gt;</span>
<span class="org-sh-heredoc">done</span>
</pre>
</div>
<p>
References: <a href="#orgf0e8fac">list-branches</a>, <a href="#orgf2ecb5e">handle-branch</a>
</p>

<p>
Used by: <a href="#org69b2cda">top-level</a>
</p>


<p>
The remotes are configured to make sure that a default fetch always fetch all tags, and also puts them in their own namespace. The default refspec for tags is <code>+refs/tags/*:refs/tags/*</code>, as you can see that puts everything from the remote at the same level in your monorepo. Obviously that will cause clashes, so we add the reponame as an extra namespace.
</p>

<p>
The <code>--no-tags</code> option is the complement to <code>--tags</code>, which has that default refspec we don‚Äôt want. That‚Äôs why we disable it and roll our own, entirely.
</p>
</div>
</div>

<div id="outline-container-org872acef" class="outline-3">
<h3 id="org872acef"><span class="section-number-3">4.2.</span> Per branch (this is where the magic happens)</h3>
<div class="outline-text-3" id="text-4-2">
<p>
In the context of <i>a single repository,</i> every branch is independently read into a subdirectory for that repository, and merged into the monorepo.
</p>

<p>
This is the money shot.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>handle-branch</label><pre class="src src-shell" id="orgf2ecb5e">&lt;&lt;ensure-on-target-branch-in-monorepo&gt;&gt;

git read-tree --prefix <span class="org-string">"$repopath"</span> <span class="org-string">"refs/remotes/$reponame/$branch"</span>
<span class="org-variable-name">tree</span>=<span class="org-string">"$(</span><span class="org-sh-quoted-exec">git write-tree</span><span class="org-string">)"</span>
<span class="org-variable-name">commit</span>=<span class="org-string">"$(</span><span class="org-sh-quoted-exec">git commit-tree \</span>
<span class="org-string">    "$tree" \</span>
<span class="org-string">    -p "$branch" \</span>
<span class="org-string">    -p "refs/remotes/$reponame/$branch" \</span>
<span class="org-string">    -m "Merge $reponame/$branch")"</span>
git reset -q <span class="org-string">"$commit"</span>
</pre>
</div>
<p>
References: <a href="#org3d3f549">ensure-on-target-branch-in-monorepo</a>
</p>

<p>
Used by: <a href="#org53653f9">handle-remote</a>
</p>


<p>
Source: <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">https://git-scm.com/book/en/v2/Git-Internals-Git-Objects</a>
</p>
</div>

<div id="outline-container-org4fee700" class="outline-4">
<h4 id="org4fee700"><span class="section-number-4">4.2.1.</span> Ensure we are on the right branch</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
In this snippet, we ensure that we are ready to merge fresh code from a subrepo into this branch: either we checkout an existing branch in the monorepo by this name, or we create a fresh one.
</p>

<p>
We are given the variable <code>$branch</code> which is the final name of the branch we want to operate on. It is the same as the name of the branch in each individual target repo.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>ensure-on-target-branch-in-monorepo</label><pre class="src src-shell" id="org3d3f549"><span class="org-keyword">if</span> <span class="org-negation-char">!</span> git show-ref --verify --quiet <span class="org-string">"refs/heads/$branch"</span>; <span class="org-keyword">then</span>
    <span class="org-variable-name">tree</span>=<span class="org-string">"$(</span><span class="org-sh-quoted-exec">git commit-tree \</span>
<span class="org-string">        "$empty_tree" \</span>
<span class="org-string">        -m "Root commit for monorepo branch $branch")"</span>
    git branch -- <span class="org-string">"$branch"</span> <span class="org-string">"$tree"</span>
<span class="org-keyword">fi</span>
git symbolic-ref HEAD <span class="org-string">"refs/heads/$branch"</span>
git reset -q
</pre>
</div>
<p>
Used by: <a href="#orgf2ecb5e">handle-branch</a>
</p>


<p>
Instead of using <code>git checkout --orphan</code> and trying to create a new empty commit from the index, we create the empty commit directly and point the new branch to it. Then, we read the branch, new or existing, into the index. Now we have the current index representing the branch, and HEAD pointing at the branch. This allows us to stay in the index and avoid the worktree.
</p>

<p>
Working with HEAD feels odd, and it requires using <code>git reset</code> to update the branch, rather than <code>git branch -f ...</code>, because the branch is checked out. This is still more reliable than not pointing HEAD at the branch, because HEAD is always pointing at <i>some</i> branch (e.g. ‚Äúmaster‚Äù), so it is easier to just assume you‚Äôre <i>always</i> pointing at the ‚Äúcurrent‚Äù branch.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/q/9765453">https://stackoverflow.com/q/9765453</a></li>
<li><a href="https://stackoverflow.com/a/6070417">https://stackoverflow.com/a/6070417</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb7c2eb1" class="outline-4">
<h4 id="orgb7c2eb1"><span class="section-number-4">4.2.2.</span> Non-goal: merging into root</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
GitHub user @woopla proposed in <a href="https://github.com/hraban/tomono/pull/42">#42</a> the ability to merge a minirepo into the monorepo root, as if you used <code>.</code> as the subdirectory. We ended up not going for it, but it was interesting to investigate how to do this with <code>git read-tree</code>. The closest I got was:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-keyword">if</span> [[ <span class="org-string">"$repopath"</span> == <span class="org-string">"."</span> ]]; <span class="org-keyword">then</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Experimental&#8212;is this how git read-tree works? I find it very confusing.</span>
    git read-tree <span class="org-string">"$branch"</span> <span class="org-string">"$reponame/$branch"</span>
<span class="org-keyword">else</span>
    git read-tree --prefix <span class="org-string">"$repopath"</span> <span class="org-string">"$reponame/$branch"</span>
<span class="org-keyword">fi</span>
</pre>
</div>

<p>
I must to confess I find the <a href="https://git-scm.com/docs/git-read-tree">git read-tree</a> man page too daunting to fully stand by this. I mostly figured it out by trial and error. It seems to work?
</p>

<p>
If anyone could explain to me exactly what this tool is supposed to do, what those separate stages are (it talks about ‚Äústage 0‚Äù to ‚Äústage 3‚Äù in its 3 way merge), and how you would cleanly do this, just for argument‚Äôs sake, I‚Äôd love to know.
</p>

<p>
But, as it turned out, this tool already has a way to merge a repo into the root: just make it the monorepo, and use it as a target for a <code>--continue</code> operation. That solves that.
</p>
</div>
</div>
</div>

<div id="outline-container-orge65d899" class="outline-3">
<h3 id="orge65d899"><span class="section-number-3">4.3.</span> Set up the monorepo directory</h3>
<div class="outline-text-3" id="text-4-3">
<p>
We create a fresh directory for this script to run in, or continue on an existing one if the <code>--continue</code> flag is passed.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>prep-dir</label><pre class="src src-shell" id="orgbc96f8c"><span class="org-comment-delimiter"># </span><span class="org-comment">Poor man&#8217;s arg parse :/</span>
<span class="org-variable-name">arg</span>=<span class="org-string">"${1-}"</span>
: <span class="org-string">"${MONOREPO_NAME:=core}"</span>

<span class="org-keyword">case</span> <span class="org-string">"$arg"</span><span class="org-keyword"> in</span>
    <span class="org-string">""</span>)
        <span class="org-keyword">if</span> [[ -d <span class="org-string">"$MONOREPO_NAME"</span> ]]; <span class="org-keyword">then</span>
            &gt;&amp;2 echo <span class="org-string">"monorepo directory $MONOREPO_NAME already exists"</span>
            <span class="org-keyword">exit</span> 1
        <span class="org-keyword">fi</span>
        mkdir <span class="org-string">"$MONOREPO_NAME"</span>
        <span class="org-builtin">cd</span> <span class="org-string">"$MONOREPO_NAME"</span>
        git init
        ;;

    <span class="org-string">"--continue"</span>)
        <span class="org-keyword">if</span> [[ <span class="org-negation-char">!</span> -d <span class="org-string">"$MONOREPO_NAME"</span> ]]; <span class="org-keyword">then</span>
            &gt;&amp;2 echo <span class="org-string">"Asked to --continue, but monorepo directory $MONOREPO_NAME doesn&#8217;t exist"</span>
            <span class="org-keyword">exit</span> 1
        <span class="org-keyword">fi</span>
        <span class="org-builtin">cd</span> <span class="org-string">"$MONOREPO_NAME"</span>
        <span class="org-keyword">if</span> git status --porcelain | grep . ; <span class="org-keyword">then</span>
            &gt;&amp;2 echo <span class="org-string">"Git status shows pending changes in the repo. Cannot --continue."</span>
            <span class="org-keyword">exit</span> 1
        <span class="org-keyword">fi</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">There isn&#8217;t anything special about --continue, really.</span>
        ;;

    <span class="org-string">"--help"</span> | <span class="org-string">"-h"</span> | <span class="org-string">"help"</span>)
        cat &lt;&lt;EOF
<span class="org-sh-heredoc">Usage: tomono [--continue]</span>

<span class="org-sh-heredoc">For more information, see the documentation at "https://tomono.0brg.net".</span>
<span class="org-sh-heredoc">EOF</span>
        <span class="org-keyword">exit</span> 0
        ;;

    *)
        &gt;&amp;2 echo <span class="org-string">"Unexpected argument: $arg"</span>
        &gt;&amp;2 echo
        &gt;&amp;2 echo <span class="org-string">"Usage: tomono [--continue]"</span>
        <span class="org-keyword">exit</span> 1
        ;;
<span class="org-keyword">esac</span>
</pre>
</div>
<p>
Used by: <a href="#org18a4165">init</a>
</p>


<p>
Most of this rigmarole is about UI, and preventing mistakes. As you can see, there is functionally no difference between continuing and starting fresh, beyond <code>mkdir</code> and <code>git init</code>. At the end of the day, every repo is read in greedily, and whether you do that on an existing monorepo, or a fresh one, doesn‚Äôt matter: every repo name you read in, is in fact itself like a <code>--continue</code> operation.
</p>

<p>
It‚Äôs horrible and kludgy but I just want to get something working out the door, for now.
</p>
</div>
</div>

<div id="outline-container-org45f071a" class="outline-3">
<h3 id="org45f071a"><span class="section-number-3">4.4.</span> List individual branches</h3>
<div class="outline-text-3" id="text-4-4">
<p>
I want a single branch name per line on stdout, for a single specific remote:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>list-branches</label><pre class="src src-shell" id="orgf0e8fac">git branch -r --no-color --list <span class="org-string">"$reponame/*"</span> --format <span class="org-string">"%(refname:lstrip=3)"</span>
</pre>
</div>
<p>
Used by: <a href="#org53653f9">handle-remote</a>
</p>
</div>


<div id="outline-container-org329585f" class="outline-4">
<h4 id="org329585f"><span class="section-number-4">4.4.1.</span> Implementations that didn‚Äôt make the cut</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
Solutions I abandoned, due to one short-coming or another:
</p>
</div>

<ol class="org-ol">
<li><a id="orgb99d0d6"></a><code>git branch -r</code> with grep<br>
<div class="outline-text-5" id="text-4-4-1-1">
<p>
The most straight-forward way to list branch names:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ git branch -r
  bar/branch-a
  bar/branch-b
  bar/master
  foo/branch-a
  foo/master
</pre>
</div>

<p>
This could be combined with <code>grep</code> to filter all branches for a specific remote, and filter out the name. It‚Äôs very close, but how do you reliably remove an unknown string?
</p>
</div>
</li>

<li><a id="org5463ac2"></a><code>find .git/refs/hooks</code><br>
<div class="outline-text-5" id="text-4-4-1-2">
<div class="org-src-container">
<pre class="src src-shell">( <span class="org-builtin">cd</span> <span class="org-string">".git/refs/remotes/$reponame"</span> &amp;&amp; find . -type f -mindepth 1 | sed -e s/..// )
</pre>
</div>

<p>
Closer, but ugly, and I got reports that it missed some branches (although I was never able to repro)
</p>
</div>
</li>

<li><a id="orgd628b6f"></a><code>git ls-remote</code><br>
<div class="outline-text-5" id="text-4-4-1-3">
<div class="org-src-container">
<pre class="src src-shell">git ls-remote --heads --refs <span class="org-string">"$reponame"</span> | sed <span class="org-string">'s_[^ ]* *refs/heads/__'</span>
</pre>
</div>

<p>
Originally suggested in a <a href="https://github.com/hraban/tomono/pull/39">PR 39</a>, I‚Äôve decided not to use this because <code>git-ls-remote</code> actively queries the remote to list its branches, rather than inspecting the local state of whatever we just fetched. That feels like a race condition at best, and becomes very annoying if you‚Äôre dealing with password protected remotes or otherwise inaccessible repos.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgf50426b" class="outline-3">
<h3 id="orgf50426b"><span class="section-number-3">4.5.</span> Init &amp; finalize</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Initialization is what you‚Äôd expect from a shell script:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>init</label><pre class="src src-shell" id="org18a4165">&lt;&lt;set-flags&gt;&gt;

&lt;&lt;prep-dir&gt;&gt;

<span class="org-sh-heredoc">empty_tree="$(</span><span class="org-sh-quoted-exec">git hash-object -t tree /dev/null</span><span class="org-sh-heredoc">)"</span>
</pre>
</div>
<p>
References: <a href="#orgbbccf3b">set-flags</a>, <a href="#orgbc96f8c">prep-dir</a>
</p>

<p>
Used by: <a href="#org69b2cda">top-level</a>
</p>


<p>
On the other side, when done, update the working tree to whatever the current branch is to avoid any confusion:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>finalize</label><pre class="src src-shell" id="org48356eb">git checkout .
</pre>
</div>
<p>
Used by: <a href="#org69b2cda">top-level</a>
</p>
</div>


<div id="outline-container-orga17798b" class="outline-4">
<h4 id="orga17798b"><span class="section-number-4">4.5.1.</span> Error flags, warnings, debug</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
Various sh flags allow us to control the behaviour of the shell: treat
any unknown variable reference as an error, treat any non-zero exit
status in a pipeline as an error (instead of only looking at the last
program), and treat any error as fatal and quit. Additionally, if the
<code>DEBUGSH</code> environment variable is set, enable &ldquo;debug&rdquo; mode by echoing
every command before it gets executed.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>set-flags</label><pre class="src src-shell" id="orgbbccf3b"><span class="org-builtin">set</span> -euo pipefail ${<span class="org-variable-name">DEBUGSH</span>+-x}

<span class="org-keyword">if</span> ((BASH_VERSINFO[0] &gt; 4 || (BASH_VERSINFO[0] == 4 &amp;&amp; BASH_VERSINFO[1] &gt;= 4))); <span class="org-keyword">then</span>
        <span class="org-builtin">shopt</span> -s inherit_errexit
<span class="org-keyword">fi</span>
</pre>
</div>
<p>
Used by: <a href="#org18a4165">init</a>
</p>


<p>
Also contains a monstrosity which is essentially a version guard around the <code>inherit_errexit</code> option, which was only introduced in Bash 4.4. Notably Mac‚Äôs default bash doesn‚Äôt support it so the version guard is useful.
</p>
</div>
</div>

<div id="outline-container-org94910a2" class="outline-4">
<h4 id="org94910a2"><span class="section-number-4">4.5.2.</span> Windows newline fix</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
On Windows the config file could contain windows newline endings (CRLF). Bash doesn‚Äôt handle those as proper field separators. Even on Windows&#x2026;
</p>

<p>
We force it by adding CR as a field separator:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>windows-fix</label><pre class="src src-shell" id="org23b82b3"><span class="org-variable-name">IFS</span>=$<span class="org-string">'\r'"$IFS"</span>
</pre>
</div>
<p>
Used by: <a href="#org69b2cda">top-level</a>
</p>


<p>
It can‚Äôt hurt to do this on other computers, because who has a carriage return in their repo name or path? Nobody does.
</p>

<p>
The real question is: why is this not standard in Bash for Windows? Who knows. I‚Äôd add it to my .bashrc if I were you ü§∑‚Äç‚ôÄÔ∏è.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-tests" class="outline-2">
<h2 id="tests"><span class="section-number-2">5.</span> Tests</h2>
<div class="outline-text-2" id="text-tests">
<blockquote>
<p>
(This section is best viewed in <a href="https://tomono.0brg.net/#tests">HTML form</a>; the GitHub Readme viewer misses some info.)
</p>
</blockquote>

<p>
The examples from this document can be combined into a test script:
</p>

<div class="org-src-container">
<pre class="src src-shell" id="org4ae6ed4"><span class="org-builtin">set</span> -euo pipefail ${<span class="org-variable-name">DEBUGSH</span>+-x}

<span class="org-keyword">if</span> ((BASH_VERSINFO[0] &gt; 4 || (BASH_VERSINFO[0] == 4 &amp;&amp; BASH_VERSINFO[1] &gt;= 4))); <span class="org-keyword">then</span>
        <span class="org-builtin">shopt</span> -s inherit_errexit
<span class="org-keyword">fi</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">In tests always echo the command:</span>
<span class="org-builtin">set</span> -x
<span class="org-builtin">export</span> <span class="org-variable-name">DEBUGSH</span>=true

<span class="org-comment-delimiter"># </span><span class="org-comment">The tomono script is tangled right next to the test script</span>
<span class="org-builtin">export</span> <span class="org-variable-name">PATH</span>=<span class="org-string">"$PWD:$PATH"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Ensure testing always works even on unconfigured CI etc</span>
<span class="org-builtin">export</span> <span class="org-variable-name">GIT_AUTHOR_NAME</span>=<span class="org-string">"Test"</span>
<span class="org-builtin">export</span> <span class="org-variable-name">GIT_AUTHOR_EMAIL</span>=<span class="org-string">"test@test.com"</span>
<span class="org-builtin">export</span> <span class="org-variable-name">GIT_COMMITTER_NAME</span>=<span class="org-string">"Test"</span>
<span class="org-builtin">export</span> <span class="org-variable-name">GIT_COMMITTER_EMAIL</span>=<span class="org-string">"test@test.com"</span>

<span class="org-variable-name">d</span>=<span class="org-string">"$(</span><span class="org-sh-quoted-exec">mktemp -d</span><span class="org-string">)"</span>
<span class="org-builtin">echo</span> <span class="org-string">"Setting up fresh multi-repos in $d"</span>
<span class="org-builtin">cd</span> <span class="org-string">"$d"</span>

mkdir foo
(
    <span class="org-builtin">cd</span> foo
    git init
    git commit -m <span class="org-string">"foo&#8217;s empty root"</span> --allow-empty
    <span class="org-builtin">echo</span> <span class="org-string">"This is foo"</span> &gt; i-am-foo.txt
    git add -A
    git commit -m <span class="org-string">"foo&#8217;s master"</span>
    git tag v1.0
    git checkout -b branch-a
    <span class="org-builtin">echo</span> <span class="org-string">"I am a new foo feature"</span> &gt; feature-a.txt
    git add -A
    git commit -m <span class="org-string">"foo&#8217;s feature branch A"</span>
)

mkdir &#20013;&#25991;
(
    <span class="org-builtin">cd</span> &#20013;&#25991;
    git init
    <span class="org-builtin">echo</span> <span class="org-string">"&#20320;&#22909;"</span> &gt; &#20320;&#22909;.txt
    git add -A
    git commit -m <span class="org-string">"&#20013;&#25991;&#30340;root"</span>
    git tag v1.0
    git checkout -b branch-a
    <span class="org-builtin">echo</span> <span class="org-string">"&#20320;&#22909; from feature-a"</span> &gt; feature-a.txt
    git add -A
    git commit -m <span class="org-string">"new &#20013;&#25991; feature branch A"</span>
    git branch branch-b master
    git checkout branch-b
    <span class="org-builtin">echo</span> <span class="org-string">"I am an entirely new &#20013;&#25991; feature: B"</span> &gt; feature-b.txt
    git add -A
    git commit -m <span class="org-string">"&#20013;&#25991;&#8217;s feature branch B"</span>
)
mkdir zimlib
(
    <span class="org-builtin">cd</span> zimlib
    git init
    <span class="org-builtin">echo</span> <span class="org-string">"This is zim"</span> &gt; i-am-zim.txt
    git add -A
    git commit -m <span class="org-string">"zim&#8217;s master"</span>
    git checkout -b branch-a
    <span class="org-builtin">echo</span> <span class="org-string">"I am a new zim feature"</span> &gt; feature-a.txt
    git add -A
    git commit -m <span class="org-string">"zim&#8217;s feature branch A"</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">And some more weird stuff, to mess with you</span>
    git checkout master
    git checkout -d
    <span class="org-builtin">echo</span> top secret &gt; james-bond.txt
    git add -A
    git commit -m <span class="org-string">"I am unreachable"</span>
    git tag leaking-you HEAD
    git checkout --orphan empty-branch
    git rm --cached -r .
    git clean -dfx
    git commit -m <span class="org-string">"zim&#8217;s tricky empty orphan branch"</span> --allow-empty
)
tomono &lt;&lt;EOF
<span class="org-sh-heredoc">$PWD/foo foo</span>
<span class="org-sh-heredoc">$PWD/&#20013;&#25991; &#20013;&#25991;</span>
<span class="org-sh-heredoc">EOF</span>
<span class="org-builtin">echo</span> <span class="org-string">"$PWD/zimlib zim lib/zim"</span> | tomono --continue
(
<span class="org-builtin">cd</span> core

<span class="org-builtin">echo</span> <span class="org-string">"Checking branch list"</span>
diff -u &lt;(git branch --no-color --list --format <span class="org-string">"%(refname:lstrip=2)"</span> | sort) &lt;(cat &lt;&lt;EOF
<span class="org-sh-heredoc">branch-a</span>
<span class="org-sh-heredoc">branch-b</span>
<span class="org-sh-heredoc">empty-branch</span>
<span class="org-sh-heredoc">master</span>
<span class="org-sh-heredoc">EOF</span>
)

<span class="org-builtin">echo</span> <span class="org-string">"Checking master"</span>
git checkout master
diff -u &lt;(find . -name <span class="org-string">'*.txt'</span> | sort | xargs head) &lt;(cat &lt;&lt;EOF
<span class="org-sh-heredoc">==&gt; ./foo/i-am-foo.txt &lt;==</span>
<span class="org-sh-heredoc">This is foo</span>

<span class="org-sh-heredoc">==&gt; ./lib/zim/i-am-zim.txt &lt;==</span>
<span class="org-sh-heredoc">This is zim</span>

<span class="org-sh-heredoc">==&gt; ./&#20013;&#25991;/&#20320;&#22909;.txt &lt;==</span>
<span class="org-sh-heredoc">&#20320;&#22909;</span>
<span class="org-sh-heredoc">EOF</span>
)

<span class="org-builtin">echo</span> <span class="org-string">"Checking branch-a"</span>
git checkout branch-a
diff -u &lt;(find . -name <span class="org-string">'*.txt'</span> | sort | xargs head) &lt;(cat &lt;&lt;EOF
<span class="org-sh-heredoc">==&gt; ./foo/feature-a.txt &lt;==</span>
<span class="org-sh-heredoc">I am a new foo feature</span>

<span class="org-sh-heredoc">==&gt; ./foo/i-am-foo.txt &lt;==</span>
<span class="org-sh-heredoc">This is foo</span>

<span class="org-sh-heredoc">==&gt; ./lib/zim/feature-a.txt &lt;==</span>
<span class="org-sh-heredoc">I am a new zim feature</span>

<span class="org-sh-heredoc">==&gt; ./lib/zim/i-am-zim.txt &lt;==</span>
<span class="org-sh-heredoc">This is zim</span>

<span class="org-sh-heredoc">==&gt; ./&#20013;&#25991;/feature-a.txt &lt;==</span>
<span class="org-sh-heredoc">&#20320;&#22909; from feature-a</span>

<span class="org-sh-heredoc">==&gt; ./&#20013;&#25991;/&#20320;&#22909;.txt &lt;==</span>
<span class="org-sh-heredoc">&#20320;&#22909;</span>
<span class="org-sh-heredoc">EOF</span>
)
)

mkdir duplicates
(
  <span class="org-builtin">cd</span> duplicates
  git init -b check-dupes
  <span class="org-builtin">echo</span> a &gt; a
  <span class="org-builtin">echo</span> b &gt; b
  git add -A
  git commit -m commit1 a
  git tag check-dupes
  git commit -m commit2 b
)
<span class="org-builtin">echo</span> <span class="org-string">"$PWD/duplicates duplicates"</span> | tomono --continue
(
  <span class="org-builtin">cd</span> core
  git checkout check-dupes
  <span class="org-comment-delimiter"># </span><span class="org-comment">This file must exist</span>
  diff -u duplicates/a &lt;(<span class="org-builtin">echo</span> a)
  <span class="org-comment-delimiter"># </span><span class="org-comment">This file too</span>
  diff -u duplicates/b &lt;(<span class="org-builtin">echo</span> b)
)
</pre>
</div>

<p>
All we needed to write was the code that actually evaluates the tests and fixtures.
</p>

<p>
I use that weird <code>diff -u &lt;(..)</code> trick instead of a string compare like <code>[[ "foo" == "..." ]]</code> , because the diff shows you where the problem is, instead of just failing the test without comment.
</p>
</div>

<div id="outline-container-org5ab2025" class="outline-3">
<h3 id="org5ab2025"><span class="section-number-3">5.1.</span> Edge case: same branch and tag name</h3>
<div class="outline-text-3" id="text-5-1">
<p>
If you have a branch and tag with the same name in a git repo, you will be familiar with this error:
</p>

<blockquote>
<p>
warning: refname &rsquo;foo&rsquo; is ambiguous.
</p>
</blockquote>

<p>
See <a href="https://github.com/hraban/tomono/issues/53">#53</a>. This happens whenever you refer to the tag or branch by its bare name, without specifying whether it‚Äôs a tag or a branch. To fix this, the monorepo script must always use <code>refs/heads/...</code> to specify the branch name.
</p>

<p>
Example:
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir duplicates
(
  <span class="org-builtin">cd</span> duplicates
  git init -b check-dupes
  <span class="org-builtin">echo</span> a &gt; a
  <span class="org-builtin">echo</span> b &gt; b
  git add -A
  git commit -m commit1 a
  git tag check-dupes
  git commit -m commit2 b
)
</pre>
</div>

<p>
We now have a <code>duplicates</code> repository with a branch <i>and</i> tag <code>check-dupes</code>, pointing at different revisions. After including it in the monorepo:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">echo</span> <span class="org-string">"$PWD/duplicates duplicates"</span> | tomono --continue
</pre>
</div>

<p>
We should get:
</p>

<div class="org-src-container">
<pre class="src src-shell">(
  <span class="org-builtin">cd</span> core
  git checkout check-dupes
  <span class="org-comment-delimiter"># </span><span class="org-comment">This file must exist</span>
  diff -u duplicates/a &lt;(<span class="org-builtin">echo</span> a)
  <span class="org-comment-delimiter"># </span><span class="org-comment">This file too</span>
  diff -u duplicates/b &lt;(<span class="org-builtin">echo</span> b)
)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org80755b8" class="outline-2">
<h2 id="org80755b8"><span class="section-number-2">6.</span> Copyright and license</h2>
<div class="outline-text-2" id="text-6">
<p>
This is a cleanroom reimplementation of the tomono.sh script, originally written with copyright assigned to Ravelin Ltd., a UK fraud detection company. There were some questions around licensing, and it was unclear how to go forward with maintenance of this project given its dispersed copyright, so I went ahead and rewrote the entire thing for a fresh start.
</p>

<p>
The license and copyright attribution of this entire document can now be set:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>copyright</label><pre class="src src-fundamental" id="org36a558f">Copyright &#169; 2020, 2022, 2023 Hraban Luyat

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <a href="https://www.gnu.org/licenses/">&lt;https://www.gnu.org/licenses/&gt;</a>.
</pre>
</div>
<p>
Used by: <a href="#org69b2cda">top-level</a>
</p>


<p>
I did not look at the original implementation at all while developing this.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-03-17 Sun 07:03</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1 (<a href="https://orgmode.org">Org</a> mode 9.6.6)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>